{% doc %}
  Script blocker that defers loading of certain scripts to improve page load performance
{% enddoc %}


<script>
// Place this at the very top of <head>
  (() => {
    console.debug('[ScriptBlocker] Initializing...');
    
    // Regex patterns to match script or stylesheet URLs to defer.
    // Use full or partial matches for file names or paths.
    // Example: 
    //   /main\.bundle\.js/ matches exact file
    //   /klaviyo.*\.js/ matches any Klaviyo JS file
    //   /judge\.me.*\.(js|css)/ matches Judge.me JS or CSS files
    // Matches partial URLs or filenames (expanded to catch more variations)
    const blockedPatterns = [
      "preloads.js",
      "storefront/load_feature",
      "shopify_pay/storefront",
      "preview-bar-modules.js",
      "model-viewer-ui.en.js",
      "shopify-xr.en.js",
      "analytics.js",
      "contactform-v2.js",
      "klaviyo.js",
      "gorgias",
      "avada-cookie.js",
      "cartbite-embed.js",
      "ecomsend.js",
      "bugsnag",
      "youtube.com/iframe_api",
      "www-widgetapi.js",
      "replace-mailto-script.js",
      "dyn-rev"
    ];

    const blockedDomains = [
      "static.klaviyo.com",
      "cdnwidget.judge.me",
      "cdn.jsdelivr.net",
      "gorgias.chat",
      "cartbite-app-api.staqlab.com",
      "cookie.avada.io",
      "api.ecomsend.com",
      "d2wy8f7a9ursnm.cloudfront.net", // bugsnag
      "www.youtube.com",
      "i.ytimg.com",
      "s1.staq-cdn.com"
    ];
    
    // Store deferred scripts in an array to preserve order
    const deferredScripts = [];
    // Use a Set just to track what we've already seen (for deduplication)
    const seenScripts = new Set();
    
    // 1. INTERCEPT DOCUMENT.WRITE
    const originalWrite = document.write;
    document.write = function(html) {
      const filtered = html.replace(/<script\b([^>]*)src=["']([^"']+)["']([^>]*)>/gi, 
        (match, prefix, src, suffix) => {
          if (shouldDefer(src)) {
            addDeferredScript(src);
            console.debug('[ScriptBlocker] Deferred via document.write:', src);
            return `<script${prefix}type="text/plain" data-deferred-src="${src}"${suffix}>`;
          }
          return match;
        });
      return originalWrite.call(document, filtered);
    };
    
    // 2. OBSERVER APPROACH
    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach(node => {
            // Handle direct script tags
            if (node.tagName === 'SCRIPT' && node.src && !node.dataset.processed) {
              if (shouldDefer(node.src)) {
                addDeferredScript(node.src);
                node.type = 'text/plain';
                node.dataset.processed = 'true';
                console.debug('[ScriptBlocker] Deferred via observer:', node.src);
              } else {
                console.debug('[ScriptBlocker] Not deferred via observer:', node.src);
              }
            }
            
            // Handle scripts in subtree
            if (node.querySelectorAll) {
              node.querySelectorAll('script[src]:not([data-processed])').forEach(script => {
                if (shouldDefer(script.src)) {
                  addDeferredScript(script.src);
                  script.type = 'text/plain';
                  script.dataset.processed = 'true';
                  console.debug('[ScriptBlocker] Deferred via observer in subtree:', script.src);
                }
              });
            }
          });
        }
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    
    // Helper function to add script to deferred list (avoiding duplicates)
    function addDeferredScript(src) {
      if (!seenScripts.has(src)) {
        seenScripts.add(src);
        deferredScripts.push(src);
      }
    }
    
    // Helper function to check if a script should be deferred
    function shouldDefer(src) {
      try {
        const url = new URL(src, window.location.href);
        // Check domain
        if (blockedDomains.some(domain => 
            url.hostname === domain || url.hostname.endsWith('.' + domain))) {
          return true;
        }
        
        // Check patterns
        return blockedPatterns.some(pattern => {
          const regex = new RegExp(pattern.replace(/\./g, '\\.').replace(/\*/g, '.*'));
          return regex.test(url.href) || regex.test(url.pathname);
        });
      } catch (e) {
        return false;
      }
    }
    
    // Load deferred scripts after DOMContentLoaded
    window.addEventListener('load', () => {
      console.debug('[ScriptBlocker] load, loading deferred scripts...');
      // Disconnect observer to prevent it from seeing our new script tags
      observer.disconnect();
      
      // Add each deferred script back with defer attribute, in original order
      deferredScripts.forEach((src, index) => {
        const script = document.createElement('script');
        script.src = src;
        script.defer = true;
        document.head.appendChild(script);
        console.debug(`[ScriptBlocker] Loading deferred script #${index + 1}:`, src);
      });
    });
    
    console.debug('[ScriptBlocker] Initialization complete');
  })();
</script>

