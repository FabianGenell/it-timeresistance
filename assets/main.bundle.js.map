{"version":3,"file":"main.bundle.js","sources":["../src/scripts/components/favorites.js","../src/scripts/components/reload-on-event.js","../src/scripts/components/currency-selector.js","../src/scripts/components/section-tab-navigator.js","../src/scripts/utils/utils.js","../src/scripts/components/expand-text.js","../src/scripts/utils/helpers/pause-outside-videos.js","../src/scripts/components/responsive-video.js","../src/scripts/utils/helpers/lightbox-custom.js","../src/scripts/utils/helpers/lazy-images.js","../src/scripts/utils/helpers/theme-helpers.js","../src/entrypoints/theme.js"],"sourcesContent":["class FavoriteHandler {\n    constructor() {\n        this.favorites = this.fetchFavorites();\n\n        this.displayCountEls = document.querySelectorAll('[data-js-favorites-count]');\n\n        this.updateDisplayCount();\n\n        console.debug('Favorites', this.favorites);\n    }\n\n    fetchFavorites() {\n        const storedFavorites = localStorage.getItem('favorites');\n        let favorites = [];\n        if (storedFavorites) {\n            try {\n                const parsed = JSON.parse(storedFavorites);\n                if (Array.isArray(parsed)) {\n                    favorites = parsed;\n                }\n            } catch (error) {\n                console.error('Error parsing favorites from localStorage', error);\n            }\n        }\n        return favorites;\n    }\n\n    removeFavorite(favoriteItem) {\n        this.favorites = this.favorites.filter((favorite) => favorite.handle !== favoriteItem.handle);\n        console.debug('Favorites after removal', this.favorites);\n        this.updateLocalStorage(this.favorites);\n        this.updateDisplayCount();\n    }\n\n    addFavorite(favoriteItem) {\n        this.favorites.push(favoriteItem);\n        console.debug('Favorites after addition', this.favorites);\n        this.updateLocalStorage(this.favorites);\n        this.updateDisplayCount();\n    }\n\n    updateDisplayCount() {\n        this.displayCountEls.forEach((el) => {\n            el.textContent = this.favorites.length;\n\n            if (this.favorites.length === 0) {\n                el.classList.add('opacity-0');\n            } else {\n                el.classList.remove('opacity-0');\n            }\n        });\n    }\n\n    updateLocalStorage(favorites) {\n        localStorage.setItem('favorites', JSON.stringify(favorites));\n    }\n}\n\nconst favoriteHandler = new FavoriteHandler();\n\n/**\n * Represents the MainFavorites custom element.\n * @class\n * @extends HTMLElement\n */\nclass FavoriteProducts extends HTMLElement {\n    constructor() {\n        super();\n\n        this.productGrid = this.querySelector('[data-product-grid]');\n        this.spinner = this.querySelector('[data-spinner]');\n        this.emptyStateEl = this.querySelector('[data-empty-state]');\n\n        if (favoriteHandler.favorites.length > 0) {\n            this.fetchProducts();\n        } else {\n            this.emptyStateEl.classList.remove('hidden');\n            this.spinner.classList.add('hidden');\n        }\n    }\n\n    /**\n     * Fetches the HTML content of a product using its handle and variant ID if available.\n     *\n     * @param {Object} favorite - The favorite object containing handle and optional variantId.\n     * @returns {Promise<HTMLLIElement>} - A promise that resolves to an HTML list item element containing the fetched product HTML.\n     */\n    async fetchProductHTML(favorite) {\n        let url = `/products/${favorite.handle}?view=card`;\n\n        if (favorite.variantId) {\n            url += `&variant=${favorite.variantId}`;\n        }\n\n        const productHTML = await fetch(url).then((res) => res.text());\n\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(productHTML, 'text/html');\n        const favoritesResult = doc.querySelector('.product-item');\n\n        return favoritesResult;\n    }\n\n    batchArray(arr, size) {\n        const batchedArray = [];\n        for (let i = 0; i < arr.length; i += size) {\n            batchedArray.push(arr.slice(i, i + size));\n        }\n        return batchedArray;\n    }\n\n    /**\n     * Fetches products and appends them to the product grid.\n     * @returns {Promise<Array<HTMLElement>>} An array of HTML elements representing the fetched products.\n     */\n    async fetchProducts() {\n        const batchedFavorites = this.batchArray(favoriteHandler.favorites, 4);\n        await Promise.all(\n            batchedFavorites.map(async (favoritesArray) => {\n                const productsHTML = await Promise.all(\n                    favoritesArray.map(async (favorite) => this.fetchProductHTML(favorite))\n                );\n                productsHTML.forEach((el) => {\n                    try {\n                        return this.productGrid.appendChild(el);\n                    } catch (error) {}\n                });\n                return productsHTML;\n            })\n        );\n        this.spinner.classList.add('hidden');\n    }\n}\n\ncustomElements.define('favorite-products', FavoriteProducts);\n\nclass AddFavorite extends HTMLElement {\n    constructor() {\n        super();\n\n        this.productHandle = this.dataset.productHandle;\n        this.variantId = this.dataset.variantId;\n\n        this.favoriteItem = {\n            handle: this.productHandle\n        };\n\n        if (this.variantId) {\n            this.favoriteItem.variantId = this.variantId;\n        }\n\n        this.addEventListener('click', this.handleClick.bind(this));\n        this.updateState();\n    }\n\n    get isFavorite() {\n        return favoriteHandler.favorites.some(\n            (favorite) => JSON.stringify(favorite) === JSON.stringify(this.favoriteItem)\n        );\n    }\n\n    handleClick() {\n        if (this.isFavorite) {\n            this.removeFavorite();\n        } else {\n            this.addFavorite();\n        }\n        this.updateState();\n    }\n\n    removeFavorite() {\n        favoriteHandler.removeFavorite(this.favoriteItem);\n    }\n\n    addFavorite() {\n        favoriteHandler.addFavorite(this.favoriteItem);\n    }\n\n    updateState() {\n        if (this.isFavorite) {\n            this.setAttribute('added', '');\n        } else {\n            this.removeAttribute('added');\n        }\n    }\n}\n\ncustomElements.define('add-favorite', AddFavorite);\n","//chrom console: -url:https://au.timeresistance.com/cdn/shopifycloud/shopify-xr-js/v1.0/shopify-xr.en.js -url:chrome-extension://hdokiejnpimakedhajhdlcegeplioahd/background-redux-new.js -url:https://au.timeresistance.com/cdn/shopifycloud/media-analytics/v0.1/analytics.js -runtime.lastError -ERR_BLOCKED\nclass ReloadOnEvent extends HTMLElement {\n    constructor() {\n        super();\n\n        console.debug('ReloadOnEvent constructor');\n\n        this.event = this.getAttribute('data-event');\n\n        this.section = this.closest('.shopify-section');\n        this.sectionId = this.section.id;\n        this.shopifySectionId = this.sectionId.replace('shopify-section-', '');\n\n        this.container = this.section.querySelector('[data-section-type]');\n        this.sectionType = this.container.getAttribute('data-section-type');\n\n        this.init();\n    }\n\n    init() {\n        this.url = new URL(window.location.href);\n        this.url.searchParams.set('sections', this.shopifySectionId);\n\n        console.debug('ReloadOnEvent init, adding event listener for', this.event);\n        document.addEventListener(this.event, this.handleChange.bind(this));\n    }\n\n    handleChange(event) {\n        console.debug('ReloadOnEvent handleChange, reloading - event.detail:', event.detail);\n\n        if (event.detail.variant) {\n            this.url.searchParams.set('variant', event.detail.variant.id);\n        }\n\n        this.reload();\n    }\n\n    async reload() {\n        await this.setNewHTML();\n        window.Shopify.theme.sections.unload(this.container);\n\n        const newContainer = this.querySelector(`[data-section-type=\"${this.sectionType}\"]`);\n\n        if (!newContainer) {\n            console.error(\n                `ReloadOnEvent reload: Failed to find the new container element with type [${this.sectionType}] after updating innerHTML.`\n            );\n\n            return;\n        }\n\n        this.container = newContainer;\n\n        window.Shopify.theme.sections.load(this.sectionType, this.container);\n\n        this.dispatchEvent(\n            new CustomEvent('reload-on-event:loaded', {\n                bubbles: true,\n                detail: {\n                    sectionId: this.sectionId,\n                    shopifySectionId: this.shopifySectionId\n                }\n            })\n        );\n    }\n\n    async setNewHTML() {\n        try {\n            const html = await this.fetchSectionHTML();\n            if (!html) {\n                console.error(\n                    'ReloadOnEvent setNewHTML: Fetched HTML is empty or null for section',\n                    this.shopifySectionId\n                );\n                return;\n            }\n\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(html, 'text/html');\n\n            const fetchedShopifySection = doc.getElementById(this.sectionId);\n\n            if (fetchedShopifySection) {\n                const fetchedSelf = this.findSelfInHTML(fetchedShopifySection);\n\n                if (fetchedSelf) {\n                    this.innerHTML = fetchedSelf.innerHTML;\n                } else {\n                    console.warn(\n                        'ReloadOnEvent setNewHTML: Could not find \"self\" (<reload-on-event>) element within the fetched section HTML using findSelfInHTML.'\n                    );\n                }\n            } else {\n                console.warn(\n                    'ReloadOnEvent setNewHTML: Could not find the parent Shopify section element in the fetched HTML. Section ID:',\n                    this.sectionId\n                );\n            }\n        } catch (error) {\n            console.error('ReloadOnEvent setNewHTML: Error fetching or parsing HTML:', error);\n        }\n    }\n\n    async fetchSectionHTML() {\n        console.debug('ReloadOnEvent fetchSectionHTML, url', this.url);\n        const sectionJSON = await fetch(this.url).then((res) => res.json());\n\n        console.debug('ReloadOnEvent fetchSectionHTML, sectionJSON', sectionJSON);\n\n        return sectionJSON[this.shopifySectionId];\n    }\n\n    findSelfInHTML(doc) {\n        // Build selector path by walking up DOM tree\n        const path = [];\n        let element = this;\n        while (element) {\n            let selector = element.tagName.toLowerCase();\n            // Add nth-child if element has siblings\n            if (element.parentElement) {\n                const index = Array.from(element.parentElement.children).indexOf(element) + 1;\n                if (index > 1) {\n                    selector += `:nth-child(${index})`;\n                }\n            }\n            path.unshift(selector);\n            element = element.parentElement;\n            // Stop at section container\n            if (element && element.id === this.sectionId) break;\n        }\n        return doc.querySelector(path.join(' > '));\n    }\n}\n\ncustomElements.define('reload-on-event', ReloadOnEvent);\n","class CurrencySelector extends HTMLElement {\n    constructor() {\n        super();\n        this.select = this.querySelector('#marketSelector');\n    }\n\n    connectedCallback() {\n        if (this.select) {\n            this.setupEventListeners();\n        }\n    }\n\n    setupEventListeners() {\n        this.select.addEventListener('change', (event) => this.handleMarketChange(event));\n    }\n\n    handleMarketChange(event) {\n        const selectedOption = event.target.selectedOptions[0];\n        const targetUrl = selectedOption.dataset.url;\n\n        if (!targetUrl) return;\n\n        window.location.href = targetUrl;\n    }\n}\n\ncustomElements.define('currency-selector', CurrencySelector);\n","class SectionTabNavigator extends HTMLElement {\n    constructor() {\n        super();\n\n        if (Shopify.designMode) {\n            this.blockSelectHandler = this.blockSelectHandler || this.handleBlockSelect.bind(this);\n            this.section.addEventListener('shopify:block:select', this.blockSelectHandler);\n        }\n    }\n\n    connectedCallback() {\n        this.init();\n        this.addEventListener('click', this.handleClick.bind(this));\n    }\n\n    init() {\n        const { sectionId, activeTextClass } = this.dataset;\n        this.section = document.getElementById(sectionId);\n        this.activeTextClass = activeTextClass;\n\n        this.backgroundBlob = this.querySelector('.background-blob');\n\n        const firstNavigator = this.querySelector('[data-navigate-tab]');\n\n        if (!firstNavigator) {\n            return console.warn(\"section-tab-navigator doesn't include any navigation links\", this);\n        }\n\n        this.navigate(firstNavigator);\n    }\n\n    /**\n     * Handles the click event.\n     *\n     * @param {Event} evt - The click event object.\n     */\n    handleClick(evt) {\n        const target = evt.target.closest('[data-navigate-tab]');\n\n        if (target) {\n            this.navigate(target);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    navigate(target) {\n        this.updateUI(target);\n\n        const tabName = target.dataset.navigateTab;\n\n        const tabEls = this.section.querySelectorAll('[data-tab]');\n\n        tabEls.forEach((tabEl) => {\n            if ((tabName === 'all' || tabName === 'alla') && !tabEl.hasAttribute('data-not-all')) {\n                return tabEl.classList.remove('js-hidden');\n            }\n\n            const elTabs = tabEl.dataset.tab.split(',');\n\n            const show = elTabs.includes(tabName);\n\n            tabEl.classList.toggle('js-hidden', !show);\n        });\n\n        this.target = target;\n\n        this.section.dispatchEvent(\n            new CustomEvent('sectionTabNavigated', {\n                detail: {\n                    tabName: tabName\n                }\n            })\n        );\n    }\n\n    updateUI(target) {\n        if (this.target && this.activeTextClass) {\n            this.target.classList.remove(this.activeTextClass);\n        }\n\n        if (target && this.backgroundBlob) {\n            if (this.activeTextClass) {\n                target.classList.add(this.activeTextClass);\n            }\n\n            const targetRect = target.getBoundingClientRect();\n            const parentRect = target.offsetParent.getBoundingClientRect();\n\n            this.backgroundBlob.style.width = `${targetRect.width}px`;\n            this.backgroundBlob.style.left = `${targetRect.left - parentRect.left}px`;\n        }\n    }\n\n    handleBlockSelect(evt) {\n        const handled = handleClick(evt);\n\n        if (handled) return;\n\n        const blockEl = evt.target;\n\n        if (!blockEl) return console.warn('No block selected');\n\n        if (evt.target.classList.contains('js-hidden')) {\n            let tabs = [];\n\n            if (tabEl.hasAttribute('data-tab')) {\n                tabs = tabEl.dataset.tab.split(',');\n            }\n\n            if (tabEl.hasAttribute('data-flickity-tab')) {\n                tabs = blockEl.dataset.flickityTab.split(',');\n            }\n\n            if (tabs.length > 0) {\n                const tabName = slideTabs[0];\n                this.navigate(tabName);\n            }\n        }\n    }\n}\n\ncustomElements.define('section-tab-navigator', SectionTabNavigator);\n\n//They maybe shpuld extend eachother for DRY\nexport class RadioBlob extends HTMLElement {\n    constructor() {\n        super();\n    }\n\n    connectedCallback() {\n        this.init();\n        this.addEventListener('input', this.handleInput.bind(this));\n    }\n\n    init() {\n        this.activeTextClass = this.dataset.activeTextClass;\n\n        this.backgroundBlob = this.querySelector('.background-blob');\n\n        const firstNavigator = this.querySelector('input[type=\"radio\"]:checked');\n\n        if (!firstNavigator) {\n            return console.warn(\"section-tab-navigator doesn't include any navigation links\", this);\n        }\n\n        this.handleInput({ target: firstNavigator });\n    }\n\n    /**\n     * Handles the click event.\n     *\n     * @param {Event} evt - The click event object.\n     */\n    handleInput(evt) {\n        const target = evt.target.closest('li');\n\n        if (target) {\n            this.updateUI(target);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    updateUI(target) {\n        if (this.target && this.activeTextClass) {\n            this.target.classList.remove(this.activeTextClass);\n        }\n\n        if (target && this.backgroundBlob) {\n            if (this.activeTextClass) {\n                target.classList.add(this.activeTextClass);\n            }\n\n            const targetRect = target.getBoundingClientRect();\n            const parentRect = target.offsetParent.getBoundingClientRect();\n\n            this.backgroundBlob.style.width = `${targetRect.width}px`;\n            this.backgroundBlob.style.left = `${targetRect.left - parentRect.left}px`;\n            this.backgroundBlob.style.top = `${targetRect.top - parentRect.top}px`;\n\n            this.target = target;\n        }\n    }\n}\n\ncustomElements.define('radio-blob', RadioBlob);\n","/**\n * Returns a function that as long as it continues to be invoked, won't be triggered.\n * @param {Function} fn - Callback function.\n * @param {number} [wait=300] - Delay (in milliseconds).\n * @returns {Function}\n */\nexport function debounce(fn, wait = 300) {\n    let t;\n    return (...args) => {\n        clearTimeout(t);\n        t = setTimeout(() => fn.apply(this, args), wait);\n    };\n}\n\n/**\n * Transforms a string from kebab-case to PascalCase.\n * @param {string} str - The input string in kebab-case.\n * @returns {string} - The transformed string in PascalCase.\n */\nexport function kebabToPascalCase(str) {\n    return str\n        .split('-') // Split the string by hyphens\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1)) // Capitalize the first letter of each word\n        .join(''); // Join the words back together\n}\n\n/**\n * Logs a message to the DOM by creating an <h4> element with the message,\n * appending it to the body, and removing it after a specified delay.\n *\n * @param {string} message - The message to display in the <h4> element.\n * @param {number} [delay=3000] - The delay in milliseconds before removing the <h4> element. Default is 3000ms.\n */\nexport function logDOM(message, delay = 8000) {\n    if (window.Shopify.theme.role != 'development') return;\n    const h4 = document.createElement('h4');\n    h4.textContent = message;\n    h4.style.color = 'red';\n\n    const logDomContainer = document.querySelector('[data-dom-log]') || document.body;\n\n    logDomContainer.prepend(h4);\n\n    setTimeout(() => {\n        logDomContainer.removeChild(h4);\n    }, delay);\n}\n\n/**\n * Waits for the animation to end on the specified element.\n *\n * @param {HTMLElement} element - The element to wait for the animation to end on.\n * @param {Function} [callback] - Optional callback function to execute when the animation ends.\n * @returns {Promise<void>} A promise that resolves when the animation ends.\n */\nexport async function afterAnimationEnd(element, callback) {\n    return new Promise((resolve) => {\n        function onEnd(event) {\n            if (event.target !== element) return;\n\n            element.removeEventListener('animationend', onEnd);\n            element.removeEventListener('transitionend', onEnd);\n\n            if (typeof callback === 'function') {\n                callback();\n            } else {\n                console.warn('callback was not valid function', callback);\n            }\n\n            resolve();\n        }\n\n        element?.addEventListener('animationend', onEnd);\n        element?.addEventListener('transitionend', onEnd);\n    });\n}\n\n/**\n * Executes the provided callback function after the current call stack has cleared.\n *\n * @param {Function} callback - The function to be executed after the call stack clears.\n */\nexport function afterCallstack(callback) {\n    setTimeout(() => {\n        requestAnimationFrame(callback);\n    }, 0);\n}\n\nexport function formatMoney(cents, format = window.themeVariables.moneyFormat) {\n    if (typeof cents == 'string') {\n        cents = cents.replace('.', '');\n    }\n    let value = '';\n    const placeholderRegex = /\\{\\{\\s*(\\w+)\\s*\\}\\}/;\n\n    function formatWithDelimiters(number, precision = 2, thousands = ',', decimal = '.') {\n        if (isNaN(number) || number == null) {\n            return 0;\n        }\n\n        number = (number / 100.0).toFixed(precision);\n\n        const parts = number.split('.'),\n            dollars = parts[0].replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, `$1${thousands}`),\n            cents = parts[1] ? decimal + parts[1] : '';\n\n        return dollars + cents;\n    }\n\n    switch (format.match(placeholderRegex)[1]) {\n        case 'amount':\n            value = formatWithDelimiters(cents, 2);\n            break;\n        case 'amount_no_decimals':\n            value = formatWithDelimiters(cents, 0);\n            break;\n        case 'amount_with_comma_separator':\n            value = formatWithDelimiters(cents, 2, '.', ',');\n            break;\n        case 'amount_no_decimals_with_comma_separator':\n            value = formatWithDelimiters(cents, 0, '.', ',');\n            break;\n    }\n\n    return format.replace(placeholderRegex, value);\n}\n\nexport function truncateText(text, maxLength) {\n    if (text.length <= maxLength) return text;\n    return text.slice(0, maxLength) + '...';\n}\n","/**\n * ExpandText Component\n *\n * A custom element that collapses text to a specified number of lines or characters\n * and adds a \"See more\" button to expand the full text when clicked.\n *\n * Usage:\n * <expand-text data-lines=\"3\">\n *   <p>Your content here...</p>\n * </expand-text>\n *\n * OR:\n *\n * <expand-text data-chars=\"158\">\n *   <p>Your content here...</p>\n * </expand-text>\n *\n * Attributes:\n * - data-lines: Number of lines to show before collapsing (default: 3)\n * - data-chars: Maximum number of characters to show before collapsing (overrides data-lines if both are provided)\n */\nimport { truncateText } from '../utils/utils.js';\n\nclass ExpandText extends HTMLElement {\n    constructor() {\n        super();\n        this.expanded = false;\n    }\n\n    connectedCallback() {\n        // Check whether to use character-based or line-based truncation\n        this.chars = parseInt(this.dataset.chars, 10) || null;\n        this.lines = parseInt(this.dataset.lines || 3, 10);\n        this.init();\n    }\n\n    init() {\n        // Save original content\n        this.originalContent = this.innerHTML;\n\n        // Create wrapper for the component\n        this.wrapper = document.createElement('div');\n        this.wrapper.classList.add('expand-text-wrapper');\n\n        // Create content element\n        this.contentEl = document.createElement('div');\n        this.contentEl.classList.add('expand-text-content');\n\n        // Create button element\n        this.button = document.createElement('button');\n        this.button.type = 'button';\n        this.button.classList.add(\n            'expand-text-toggle',\n            'mt-2',\n            'text-sm',\n            'font-medium',\n            'underline',\n            'focus:outline-none',\n            'hidden'\n        );\n        this.button.textContent = 'See more';\n        this.button.addEventListener('click', () => this.toggleExpand());\n\n        let maxChars;\n\n        // If character limit is directly specified, use that\n        if (this.chars !== null) {\n            maxChars = this.chars;\n        } else {\n            // Otherwise calculate based on lines\n            // Create temporary measurement element\n            const measureEl = document.createElement('div');\n            measureEl.style.position = 'absolute';\n            measureEl.style.visibility = 'hidden';\n            measureEl.style.width = 'auto';\n            measureEl.style.height = 'auto';\n            measureEl.innerHTML = this.originalContent;\n            document.body.appendChild(measureEl);\n\n            // Calculate width for determining chars per line\n            const parentWidth = this.parentElement ? this.parentElement.offsetWidth : 500;\n            measureEl.style.width = `${parentWidth}px`;\n\n            // Measure a sample text to determine chars per line\n            const sampleText = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789';\n            const sampleEl = document.createElement('div');\n            sampleEl.textContent = sampleText;\n            sampleEl.style.whiteSpace = 'nowrap';\n            measureEl.appendChild(sampleEl);\n\n            // Calculate chars per line based on width\n            const charsPerSample = sampleText.length;\n            const sampleWidth = sampleEl.offsetWidth;\n            const charsPerLine = Math.floor((parentWidth / sampleWidth) * charsPerSample);\n\n            // Calculate total allowed characters\n            maxChars = charsPerLine * this.lines;\n\n            // Cleanup measurement elements\n            document.body.removeChild(measureEl);\n        }\n\n        // Initial setup - show truncated content if needed\n        this.setupContent(maxChars);\n\n        // Clear original content and build component\n        this.innerHTML = '';\n        this.wrapper.appendChild(this.contentEl);\n        this.appendChild(this.wrapper);\n        this.appendChild(this.button);\n    }\n\n    setupContent(maxChars) {\n        // Get plain text content to measure length\n        const tempDiv = document.createElement('div');\n        tempDiv.innerHTML = this.originalContent;\n        const textContent = tempDiv.textContent || tempDiv.innerText || '';\n\n        // Check if truncation is needed\n        const needsTruncation = textContent.length > maxChars;\n\n        if (needsTruncation) {\n            // Store original content for expanded state\n            this.fullContent = this.originalContent;\n\n            // Try to find a word boundary near the maxChars position\n            let truncatePosition = maxChars;\n            while (\n                truncatePosition > 0 &&\n                textContent.charAt(truncatePosition) !== ' ' &&\n                textContent.charAt(truncatePosition) !== '.'\n            ) {\n                truncatePosition--;\n            }\n\n            // If we couldn't find a good break point, use the max\n            if (truncatePosition === 0) {\n                truncatePosition = maxChars;\n            }\n\n            // Use the utility function to truncate at the word boundary\n            const truncatedText = truncateText(textContent, truncatePosition);\n\n            // Set truncated content\n            this.contentEl.textContent = truncatedText;\n\n            // Show the toggle button\n            this.button.classList.remove('hidden');\n            this.truncated = true;\n\n            // Store maxChars for toggle\n            this.maxChars = truncatePosition;\n        } else {\n            // No truncation needed, just set the content\n            this.contentEl.innerHTML = this.originalContent;\n            this.truncated = false;\n        }\n    }\n\n    toggleExpand() {\n        this.expanded = !this.expanded;\n\n        if (this.expanded) {\n            // Show full content (with HTML)\n            this.contentEl.innerHTML = this.originalContent;\n            this.button.textContent = 'See less';\n        } else {\n            // Show truncated content\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = this.originalContent;\n            const textContent = tempDiv.textContent || tempDiv.innerText || '';\n\n            // Use the utility function to truncate\n            const truncatedText = truncateText(textContent, this.maxChars);\n            this.contentEl.textContent = truncatedText;\n\n            this.button.textContent = 'See more';\n        }\n    }\n}\n\ncustomElements.define('expand-text', ExpandText);\n","class VideoViewportManager {\n    constructor() {\n        this.timeoutDuration = 10000; // 10 seconds\n        this.videoStates = new Map();\n        this.observer = null;\n        this.externalPlayers = new Map(); // Store YouTube/Vimeo player instances\n        this.init();\n    }\n\n    init() {\n        this.observer = new IntersectionObserver(this.handleIntersection.bind(this), {\n            threshold: 0.5\n        });\n\n        this.observeVideos();\n        this.listenForExternalPlayers();\n    }\n\n    observeVideos() {\n        // Observe regular HTML5 videos\n        document.querySelectorAll('video').forEach((video) => {\n            this.observer.observe(video);\n            this.videoStates.set(video, {\n                timeoutId: null,\n                type: 'html5'\n            });\n        });\n\n        // Observe external video containers (YouTube/Vimeo iframes)\n        document.querySelectorAll('[data-video-provider]').forEach((container) => {\n            this.observer.observe(container);\n            this.videoStates.set(container, {\n                timeoutId: null,\n                type: 'external',\n                provider: container.dataset.videoProvider\n            });\n        });\n    }\n\n    // Listen for custom events when external players are initialized\n    listenForExternalPlayers() {\n        // Listen for YouTube player ready events\n        window.addEventListener('youtube-player-ready', (event) => {\n            const { element, player } = event.detail;\n            \n            // Store the player\n            this.externalPlayers.set(element, {\n                player,\n                type: 'youtube'\n            });\n            \n            // Start observing the iframe if not already observed\n            if (!this.videoStates.has(element)) {\n                this.observer.observe(element);\n                this.videoStates.set(element, {\n                    timeoutId: null,\n                    type: 'external',\n                    provider: 'youtube'\n                });\n            }\n        });\n\n        // Listen for Vimeo player ready events\n        window.addEventListener('vimeo-player-ready', (event) => {\n            const { element, player } = event.detail;\n            \n            // Store the player\n            this.externalPlayers.set(element, {\n                player,\n                type: 'vimeo'\n            });\n            \n            // Start observing the iframe if not already observed\n            if (!this.videoStates.has(element)) {\n                this.observer.observe(element);\n                this.videoStates.set(element, {\n                    timeoutId: null,\n                    type: 'external',\n                    provider: 'vimeo'\n                });\n            }\n        });\n    }\n\n    handleIntersection(entries) {\n        entries.forEach((entry) => {\n            const element = entry.target;\n            const state = this.videoStates.get(element);\n\n            if (!state) return;\n\n            if (state.type === 'html5') {\n                this.handleHTML5Video(element, entry.isIntersecting, state);\n            } else if (state.type === 'external') {\n                this.handleExternalVideo(element, entry.isIntersecting, state);\n            }\n        });\n    }\n\n    handleHTML5Video(video, isIntersecting, state) {\n        if (isIntersecting) {\n            // Video is in viewport\n            if (state.timeoutId) {\n                clearTimeout(state.timeoutId);\n                state.timeoutId = null;\n            }\n\n            if (video.dataset.autoPaused === 'true') {\n                video.play();\n                video.dataset.autoPaused = false;\n            }\n        } else {\n            // Video is out of viewport\n            if (!video.muted && !video.paused) {\n                video.pause();\n                video.dataset.autoPaused = true;\n\n                state.timeoutId = setTimeout(() => {\n                    video.dataset.autoPaused = false;\n                    state.timeoutId = null;\n                }, this.timeoutDuration);\n            }\n        }\n    }\n\n    handleExternalVideo(element, isIntersecting, state) {\n        const playerData = this.externalPlayers.get(element);\n        if (!playerData) return; // Player not initialized yet\n\n        const { player, type } = playerData;\n\n        if (isIntersecting) {\n            // Video is in viewport\n            if (state.timeoutId) {\n                clearTimeout(state.timeoutId);\n                state.timeoutId = null;\n            }\n\n            if (element.dataset.autoPaused === 'true') {\n                if (type === 'youtube') {\n                    player.playVideo();\n                } else if (type === 'vimeo') {\n                    player.play();\n                }\n                element.dataset.autoPaused = false;\n            }\n        } else {\n            // Video is out of viewport\n            if (type === 'youtube') {\n                // Check if video is playing (1) or buffering (3)\n                const playerState = player.getPlayerState();\n                if (playerState === 1 || playerState === 3) {\n                    player.pauseVideo();\n                    element.dataset.autoPaused = true;\n\n                    state.timeoutId = setTimeout(() => {\n                        element.dataset.autoPaused = false;\n                        state.timeoutId = null;\n                    }, this.timeoutDuration);\n                }\n            } else if (type === 'vimeo') {\n                player.getPaused().then(paused => {\n                    if (!paused) {\n                        player.pause();\n                        element.dataset.autoPaused = true;\n\n                        state.timeoutId = setTimeout(() => {\n                            element.dataset.autoPaused = false;\n                            state.timeoutId = null;\n                        }, this.timeoutDuration);\n                    }\n                });\n            }\n        }\n    }\n\n    // Method to observe new videos added dynamically\n    observeNewVideos() {\n        let newVideosFound = 0;\n        \n        // Find and observe new HTML5 videos\n        document.querySelectorAll('video').forEach((video) => {\n            if (!this.videoStates.has(video)) {\n                this.observer.observe(video);\n                this.videoStates.set(video, {\n                    timeoutId: null,\n                    type: 'html5'\n                });\n                newVideosFound++;\n            }\n        });\n\n        // Find and observe new external video containers\n        document.querySelectorAll('[data-video-provider]').forEach((container) => {\n            if (!this.videoStates.has(container)) {\n                this.observer.observe(container);\n                this.videoStates.set(container, {\n                    timeoutId: null,\n                    type: 'external',\n                    provider: container.dataset.videoProvider\n                });\n                newVideosFound++;\n            }\n        });\n        \n    }\n\n    destroy() {\n        \n        // Clear all timeouts\n        this.videoStates.forEach((state) => {\n            if (state.timeoutId) {\n                clearTimeout(state.timeoutId);\n            }\n        });\n\n        // Disconnect observer\n        this.observer.disconnect();\n        this.videoStates.clear();\n        this.externalPlayers.clear();\n        \n        // Remove event listeners\n        window.removeEventListener('youtube-player-ready', this.listenForExternalPlayers);\n        window.removeEventListener('vimeo-player-ready', this.listenForExternalPlayers);\n        \n    }\n}\n\n// Initialize the manager\nconst videoManager = new VideoViewportManager();\n\nexport default videoManager;\n","/**\n * Responsive Video Web Component\n * - Switches video sources based on screen size (mobile/desktop/large)\n * - Uses poster image for aspect ratio\n * - Shows video after loading, hiding the poster\n * - Pauses video when out of viewport (using VideoViewportManager)\n * - Handles play/pause and sound toggle\n */\n\nimport videoManager from '../utils/helpers/pause-outside-videos.js';\n\nclass ResponsiveVideo extends HTMLElement {\n    constructor() {\n        super();\n    }\n\n    connectedCallback() {\n        // Initial state\n        this.state = {\n            isMuted: true,\n            isPlaying: false,\n            resizeObserver: null,\n            currentSource: null,\n            autoplayAttempted: false\n        };\n\n        this.setupElements();\n        this.bindEvents();\n        this.setupObservers();\n        this.setInitialSource();\n    }\n\n    get autoplay() {\n        return this.hasAttribute('autoplay') || this.hasAttribute('data-autoplay');\n    }\n\n    setupElements() {\n        // Get elements from the DOM\n        this.videoWrapper = this.querySelector('.responsive-video-wrapper') || this;\n        this.video = this.querySelector('video');\n        this.posterImage = this.querySelector('.poster-image');\n        this.playButton = this.querySelector('[data-play-toggle]');\n        this.soundButton = this.querySelector('[data-sound-toggle]');\n        this.playIcon = this.querySelector('[data-icon-play]');\n        this.soundOnIcon = this.querySelector('[data-icon-sound-on]');\n        this.soundOffIcon = this.querySelector('[data-icon-sound-off]');\n\n        // Set autoplay attribute on video element if needed\n        if (this.autoplay && this.video) {\n            // We don't set the autoplay attribute directly because browsers block it\n            // Instead we'll manually call play() after loading\n            this.video.muted = true; // Must be muted for autoplay to work\n        }\n\n        // Get video sources\n        this.sources = Array.from(this.video?.querySelectorAll('source') || []);\n\n        // Log all sources for debugging\n        this.sources.forEach((source, index) => {\n            const media = source.getAttribute('media') || 'default';\n            console.log(`[ResponsiveVideo] Source ${index}:`, {\n                src: source.src,\n                media: media,\n                type: source.type\n            });\n        });\n\n        // Initially hide video until loaded\n        if (this.video) {\n            this.video.style.opacity = '0';\n        } else {\n            console.error('[ResponsiveVideo] No video element found');\n        }\n    }\n\n    getActiveSource() {\n        if (!this.video || !this.sources.length) {\n            console.error('[ResponsiveVideo] Cannot get active source - video or sources missing');\n            return null;\n        }\n\n        // Check which media query is currently active\n        const viewportWidth = window.innerWidth;\n\n        // Mobile source: max-width media query\n        const mobileSource = this.sources.find((source) => {\n            const media = source.getAttribute('media');\n            if (!media || !media.includes('max-width')) return false;\n\n            const match = media.match(/\\d+/);\n            if (!match) return false;\n\n            const maxWidth = parseInt(match[0]);\n            const isActive = viewportWidth <= maxWidth;\n            console.log(`[ResponsiveVideo] Checking mobile source (max-width: ${maxWidth}px): ${isActive}`);\n            return isActive;\n        });\n\n        if (mobileSource) {\n            return mobileSource;\n        }\n\n        // Large source: min-width media query\n        const largeSource = this.sources.find((source) => {\n            const media = source.getAttribute('media');\n            if (!media || !media.includes('min-width')) return false;\n\n            const match = media.match(/\\d+/);\n            if (!match) return false;\n\n            const minWidth = parseInt(match[0]);\n            const isActive = viewportWidth >= minWidth;\n            console.log(`[ResponsiveVideo] Checking large source (min-width: ${minWidth}px): ${isActive}`);\n            return isActive;\n        });\n\n        if (largeSource) {\n            return largeSource;\n        }\n\n        // If no media query matches, use the default source (without media attribute)\n        const defaultSource = this.sources.find((source) => !source.hasAttribute('media')) || this.sources[0];\n\n        return defaultSource;\n    }\n\n    bindEvents() {\n        // Make the whole video area clickable for play/pause\n        this.videoWrapper.addEventListener('click', (e) => {\n            // Ignore clicks on the sound button\n            if (e.target.closest('[data-sound-toggle]')) {\n                return;\n            }\n\n            this.togglePlay();\n            e.preventDefault();\n        });\n\n        if (this.soundButton) {\n            this.soundButton.addEventListener('click', this.toggleSound.bind(this));\n        }\n\n        // Update control display when video state changes\n        if (this.video) {\n            this.video.addEventListener('play', () => {\n                this.state.isPlaying = true;\n                this.updateControlsUI();\n            });\n\n            this.video.addEventListener('pause', () => {\n                this.state.isPlaying = false;\n                this.updateControlsUI();\n            });\n\n            // When video is loaded, show it and hide poster\n            this.video.addEventListener('canplay', () => {\n                this.handleVideoLoaded();\n            });\n\n            // Loading events\n            this.video.addEventListener('loadstart', () => {});\n\n            this.video.addEventListener('loadeddata', () => {\n                // Try to autoplay right after data is loaded\n                if (this.autoplay && !this.state.autoplayAttempted) {\n                    this.attemptAutoplay();\n                }\n            });\n\n            // Monitor errors\n            this.video.addEventListener('error', (e) => {\n                console.error('[ResponsiveVideo] Video error:', e, this.video.error);\n            });\n        }\n    }\n\n    handleVideoLoaded() {\n        if (this.posterImage) {\n            this.posterImage.style.opacity = '0';\n        } else {\n        }\n        this.video.style.opacity = '1';\n\n        // Try autoplay if we're set to autoplay and haven't tried yet\n        if (this.autoplay && !this.state.autoplayAttempted) {\n            this.attemptAutoplay();\n        }\n    }\n\n    attemptAutoplay() {\n        if (!this.video) return;\n\n        // Mark that we've attempted autoplay to avoid multiple attempts\n        this.state.autoplayAttempted = true;\n\n        // Check if element is visible\n        const isVisible = this.isElementVisible();\n\n        if (isVisible) {\n            this.video.muted = true; // Must be muted for autoplay to work\n\n            // Set timeout to ensure the video is ready to play\n            setTimeout(() => {\n                this.video\n                    .play()\n                    .then(() => {\n                        this.state.isPlaying = true;\n                        this.updateControlsUI();\n                    })\n                    .catch((e) => {\n                        console.error('[ResponsiveVideo] Autoplay failed:', e);\n\n                        // One more retry with a longer delay\n                        setTimeout(() => {\n                            this.video\n                                .play()\n                                .then(() => {\n                                    this.state.isPlaying = true;\n                                    this.updateControlsUI();\n                                })\n                                .catch((e) => console.error('[ResponsiveVideo] Autoplay retry failed:', e));\n                        }, 1000);\n                    });\n            }, 100);\n        } else {\n        }\n    }\n\n    isElementVisible() {\n        // Simple visibility check\n        const rect = this.getBoundingClientRect();\n\n        // Element is at least partially visible in the viewport\n        const isPartiallyVisible =\n            rect.top < window.innerHeight &&\n            rect.bottom > 0 &&\n            rect.left < window.innerWidth &&\n            rect.right > 0;\n\n        return isPartiallyVisible;\n    }\n\n    setupObservers() {\n        // We're using videoManager from pause-outside-videos.js for pausing when out of viewport\n        // No need to set up our own intersection observer\n\n        // Resize observer for source updates based on viewport\n        if ('ResizeObserver' in window) {\n            this.state.resizeObserver = new ResizeObserver(this.handleResize.bind(this));\n            this.state.resizeObserver.observe(document.documentElement);\n        } else {\n            // Fallback to window resize event\n            window.addEventListener('resize', this.handleResize.bind(this));\n        }\n    }\n\n    handleResize() {\n        // Delay resize handling to avoid too many updates during resize\n        clearTimeout(this.resizeTimeout);\n        this.resizeTimeout = setTimeout(() => {\n            this.updateSourceBasedOnViewport();\n        }, 150);\n    }\n\n    setInitialSource() {\n        const activeSource = this.getActiveSource();\n        if (!activeSource || !this.video) {\n            console.error('[ResponsiveVideo] Cannot set initial source - activeSource or video missing');\n            return;\n        }\n\n        // Direct setup - do not use source tags with multiple files\n        // Set src directly on video element\n\n        this.video.src = activeSource.src;\n        this.state.currentSource = activeSource.src;\n\n        // Force video to load without autoplay\n\n        this.video.load();\n    }\n\n    updateSourceBasedOnViewport() {\n        // Update src when window size changes (which may change active source)\n        const activeSource = this.getActiveSource();\n        if (!activeSource || !this.video) {\n            console.error('[ResponsiveVideo] Cannot update source - activeSource or video missing');\n            return;\n        }\n\n        // Only update if source has changed\n        if (this.state.currentSource !== activeSource.src) {\n            // Remember current play state\n            const wasPlaying = !this.video.paused;\n\n            // Set new source directly on video tag\n            this.video.src = activeSource.src;\n            this.state.currentSource = activeSource.src;\n\n            // Reset video opacity until it's ready to play\n            this.video.style.opacity = '0';\n            if (this.posterImage) {\n                this.posterImage.style.opacity = '1';\n            }\n\n            // Force reload of the video\n\n            this.video.load();\n\n            if (wasPlaying) {\n                this.video\n                    .play()\n                    .catch((e) =>\n                        console.error('[ResponsiveVideo] Error playing video after source change:', e)\n                    );\n            }\n        } else {\n        }\n    }\n\n    togglePlay() {\n        if (!this.video) {\n            console.error('[ResponsiveVideo] Cannot toggle play - video missing');\n            return;\n        }\n\n        if (this.video.paused) {\n            // Make sure we have a source set\n            if (!this.video.src) {\n                const activeSource = this.getActiveSource();\n                if (activeSource) {\n                    this.video.src = activeSource.src;\n                    this.video.load();\n                } else {\n                    console.error('[ResponsiveVideo] No source available to play');\n                    return;\n                }\n            }\n\n            this.video.play().catch((e) => console.error('[ResponsiveVideo] Error playing video:', e));\n            this.state.isPlaying = true;\n        } else {\n            this.video.pause();\n            this.state.isPlaying = false;\n        }\n\n        this.updateControlsUI();\n    }\n\n    toggleSound() {\n        if (!this.video) {\n            console.error('[ResponsiveVideo] Cannot toggle sound - video missing');\n            return;\n        }\n\n        this.video.muted = !this.video.muted;\n        this.state.isMuted = this.video.muted;\n\n        this.updateControlsUI();\n    }\n\n    updateControlsUI() {\n        // Update play button visibility - only show when paused\n        if (this.playIcon && this.video) {\n            if (this.video.paused) {\n                this.playIcon.classList.remove('hidden');\n            } else {\n                this.playIcon.classList.add('hidden');\n            }\n        }\n\n        // Update sound button\n        if (this.soundOnIcon && this.soundOffIcon && this.video) {\n            if (this.video.muted) {\n                this.soundOnIcon.classList.add('hidden');\n                this.soundOffIcon.classList.remove('hidden');\n            } else {\n                this.soundOnIcon.classList.remove('hidden');\n                this.soundOffIcon.classList.add('hidden');\n            }\n        }\n    }\n\n    disconnectedCallback() {\n        this.destroy();\n    }\n\n    destroy() {\n        // Clear any pending resize timeout\n        if (this.resizeTimeout) {\n            clearTimeout(this.resizeTimeout);\n        }\n\n        // Remove event listeners\n        if (this.videoWrapper) {\n            this.videoWrapper.removeEventListener('click', this.togglePlay);\n        }\n\n        if (this.soundButton) {\n            this.soundButton.removeEventListener('click', this.toggleSound);\n        }\n\n        if (this.video) {\n            this.video.removeEventListener('play', this.updateControlsUI);\n            this.video.removeEventListener('pause', this.updateControlsUI);\n            this.video.removeEventListener('canplay', this.handleVideoLoaded);\n            this.video.removeEventListener('loadstart', this.handleLoadStart);\n            this.video.removeEventListener('loadeddata', this.handleLoadedData);\n            this.video.removeEventListener('error', this.handleVideoError);\n        }\n\n        // Disconnect resize observer\n        if (this.state && this.state.resizeObserver) {\n            this.state.resizeObserver.disconnect();\n        } else {\n            window.removeEventListener('resize', this.handleResize);\n        }\n\n        // We don't need to disconnect the video manager's observer\n        // It's a global singleton that manages all videos\n    }\n}\n\n// Define the custom element\nif (!customElements.get('responsive-video')) {\n    customElements.define('responsive-video', ResponsiveVideo);\n}\n\n// Module export for Shopify theme integration\nexport default {\n    init(container) {\n        // Custom elements are automatically initialized by the browser\n        // This function just ensures backward compatibility\n    },\n\n    destroy(container) {\n        // Let the disconnectedCallback handle cleanup\n    }\n};\n","const { icons: icons$1 } = window.theme;\n/**\n * Initializes a PhotoSwipe lightbox for custom media.\n * Requires PhotoSwipe modules via dynamic import (`flu.chunks.photoswipe`),\n * an icons object (`icons$1`), and specific data attributes on '.lightbox-image' elements.\n * Assumes a DOM query function `t$2` exists globally or is imported.\n */\nexport async function customLightbox({ childSelector, galerySelector, mainClass, addListener = false }) {\n    const lightboxElements = document.querySelectorAll(childSelector);\n    if (!lightboxElements.length) {\n        return;\n    }\n\n    const createDataSourceItem = (element) => {\n        const type = element.dataset.pswpType || 'image';\n        const width = parseInt(element.dataset.pswpWidth, 10);\n        const height = parseInt(element.dataset.pswpHeight, 10);\n\n        if (isNaN(width) || isNaN(height)) {\n            console.warn('Lightbox element missing valid width/height data attributes:', element);\n        }\n\n        const itemData = {\n            type,\n            width: width || 0,\n            height: height || 0,\n            element // Store element reference for later use (e.g., video source)\n        };\n\n        if (type === 'video') {\n            return itemData; // Video src retrieved later in contentLoad\n        } else {\n            itemData.src = element.getAttribute('href') || element.dataset.pswpSrc;\n            if (!itemData.src) {\n                console.warn('Image lightbox element missing href and data-pswp-src:', element);\n            }\n            return itemData;\n        }\n    };\n\n    const dataSource = Array.from(lightboxElements).map(createDataSourceItem);\n\n    const pswpModule = await import(window.flu.chunks.photoswipe); // Assumed path to PhotoSwipe module\n\n    const { PhotoSwipeLightbox, PhotoSwipe } = pswpModule;\n\n    if (!PhotoSwipeLightbox || !PhotoSwipe) {\n        console.error('PhotoSwipe modules not found in the imported chunk.');\n        return;\n    }\n\n    const lightbox = new PhotoSwipeLightbox({\n        gallery: galerySelector,\n        children: childSelector,\n        showHideAnimationType: 'zoom',\n        pswpModule: PhotoSwipe,\n        mainClass,\n        bgOpacity: 1,\n        arrowPrevSVG: icons$1?.chevron,\n        arrowNextSVG: icons$1?.chevron,\n        closeSVG: icons$1?.close,\n        zoomSVG: icons$1?.zoom,\n        dataSource: dataSource\n    });\n\n    lightbox.on('contentLoad', (e) => {\n        const { content } = e;\n        const item = content.data;\n\n        console.log('contentLoad', e, item);\n\n        if (item.type === 'video') {\n            const videoElement = item.element;\n            console.log('videoElement', videoElement.dataset);\n            const videoSrc = videoElement?.dataset.pswpVideo || videoElement?.getAttribute('href');\n\n            if (videoElement && videoSrc) {\n                e.preventDefault();\n                content.element = createVideoElement(videoSrc);\n            } else {\n                console.warn(\n                    `PhotoSwipe: Video item type detected, but failed to find video source on element:`,\n                    videoElement\n                );\n                content.state = 'error';\n            }\n        }\n    });\n\n    lightbox.on('contentActivate', (e) => {\n        const { content } = e;\n\n        const element = content.element;\n        const item = content.data;\n\n        if (item.type === 'video') {\n            console.log('contentActivate', e, content, element);\n            const video = element.querySelector('video');\n\n            if (video) {\n                content.state = 'loading';\n                setupVideoEvents(video, content);\n            } else {\n                console.error('PhotoSwipe: Failed to find video element within the created container.');\n                content.state = 'error';\n                content.onError();\n            }\n        }\n    });\n\n    lightbox.on('contentDeactivate', (e) => {\n        const { content } = e;\n\n        const element = content.element;\n        const item = content.data;\n\n        if (item.type === 'video') {\n            console.log('contentDeactivate', e, content, element);\n            const video = element.querySelector('video');\n\n            if (video) {\n                video.pause();\n            }\n        }\n    });\n\n    if (addListener) {\n        lightboxElements.forEach((element, index) => {\n            element.addEventListener('click', (e) => {\n                console.log('opening w custom clicker listneer mate click', e);\n                e.preventDefault();\n                lightbox.loadAndOpen(index);\n            });\n        });\n    }\n\n    try {\n        lightbox.init();\n    } catch (initError) {\n        console.error('PhotoSwipe: Failed to initialize lightbox.', initError);\n    }\n}\n\nwindow.customLightbox = customLightbox;\n\nconst createVideoElement = (videoSrc) => {\n    const container = document.createElement('div');\n    container.className = 'pswp__video-wrapper';\n    Object.assign(container.style, {\n        width: '100%',\n        height: '100%',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        background: '#000'\n    });\n\n    const video = document.createElement('video');\n    video.src = videoSrc;\n    video.controls = true;\n\n    Object.assign(video.style, {\n        maxWidth: '100%',\n        maxHeight: '100%',\n        display: 'block'\n    });\n\n    container.appendChild(video);\n    return container;\n};\n\nconst setupVideoEvents = (video, content) => {\n    let loaded = false;\n    const onLoaded = () => {\n        if (loaded) return;\n        loaded = true;\n        video.play();\n        content.onLoaded();\n    };\n    const onError = (event) => {\n        console.error(`PhotoSwipe: Video loading failed for src: ${video.src}`, event);\n        content.onError();\n    };\n\n    video.addEventListener('loadeddata', onLoaded);\n    video.addEventListener('canplay', onLoaded);\n    video.addEventListener('error', onError);\n    video.addEventListener('stalled', onError);\n\n    if (video.readyState >= 3) {\n        // HAVE_FUTURE_DATA or higher\n        onLoaded();\n    }\n};\n","import { afterCallstack } from '../utils.js';\n\n/**\n * Checks if a lazy load image has alternate <source> elements and copies the\n * 'data-src' and 'data-srcset' selectors to 'src' and 'srcset' accordingly.\n * @param {Element} img - Image element.\n */\nexport function setImageSources(img) {\n    const setImageAttr = (el) => {\n        if (el.dataset.src && !el.src) {\n            el.src = el.dataset.src;\n        }\n\n        if (el.dataset.srcset && !el.srcset) {\n            el.srcset = el.dataset.srcset;\n        }\n    };\n\n    if (img.parentNode.tagName === 'PICTURE') {\n        Array.from(img.parentNode.children).forEach((el) => {\n            setImageAttr(el);\n        });\n    } else {\n        setImageAttr(img);\n    }\n}\n\nfunction setImageSourceArray(imgElArray) {\n    return imgElArray.forEach((img) => setImageSources(img));\n}\n\n/**\n * Initialises lazy load images.\n */\nexport function initLazyImages() {\n    if ('loading' in HTMLImageElement.prototype === false && 'IntersectionObserver' in window) {\n        console.log('intersection observer');\n        const io = new IntersectionObserver(\n            (entries, observer) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        const img = entry.target;\n                        setImageSources(img);\n                        observer.unobserve(img);\n                    }\n                });\n            },\n            { rootMargin: '0px 0px 500px 0px' }\n        );\n\n        document.querySelectorAll('[loading=\"lazy\"]').forEach((img) => {\n            io.observe(img);\n        });\n    } else {\n        // If native lazy load supported or IntersectionObserver not supported (legacy browsers).\n        const imagesOnDOMLoad = [];\n        const imagesOnLoad = [];\n\n        document.querySelectorAll('[loading=\"lazy\"], [data-src]').forEach((img) => {\n            if (img.hasAttribute('data-load-dom')) {\n                imagesOnDOMLoad.push(img);\n            } else if (img.hasAttribute('data-load-load')) {\n                imagesOnLoad.push(img);\n            } else if (img.hasAttribute('data-load-manual')) {\n                return;\n            } else {\n                setImageSources(img);\n            }\n        });\n\n        loadImagesOnDOMLoaded(imagesOnDOMLoad);\n\n        loadImagesOnLoaded(imagesOnLoad);\n    }\n}\n\nfunction loadImagesOnDOMLoaded(imageElArray) {\n    console.debug('loadImagesOnDOMLoaded', imageElArray);\n    const execute = () => afterCallstack(() => setImageSourceArray(imageElArray));\n\n    if (document.readyState != 'loading') {\n        return execute();\n    }\n\n    document.addEventListener('DOMContentLoaded', execute);\n}\n\nfunction loadImagesOnLoaded(imageElArray) {\n    console.debug('loadImagesOnLoaded', imageElArray);\n    const execute = () => afterCallstack(() => setImageSourceArray(imageElArray));\n\n    if (document.readyState == 'complete') {\n        return execute();\n    }\n\n    window.addEventListener('load', execute);\n}\n\n//Loads all images manually (load,dom,manual, etc.)\nexport function loadManualImages(container = document) {\n    console.debug('loadManualImages', container);\n    const imageEls = container.querySelectorAll('[loading=\"lazy\"]');\n\n    setImageSourceArray(imageEls);\n}\n\nafterCallstack(initLazyImages);\ndocument.addEventListener('DOMContentLoaded', initLazyImages);\n\ndocument.addEventListener('shopify:section:load', () => afterCallstack(initLazyImages));\n","document.addEventListener('DOMContentLoaded', () => {\n    document.addEventListener('click', (evt) => {\n        const link = evt.target.tagName === 'A' ? evt.target : evt.target.closest('a');\n        if (link && link.tagName === 'A' && window.location.hostname !== new URL(link.href).hostname) {\n            link.target = '_blank';\n        }\n    });\n\n    // Ensure anchor scrolling is smooth (this shouldn't be added in the CSS)\n    document.addEventListener('click', (evt) => {\n        if (\n            evt.target.tagName === 'A' &&\n            window.location.hostname === new URL(evt.target.href).hostname &&\n            evt.target.href.includes('#')\n        ) {\n            document.getElementsByTagName('html')[0].style.scrollBehavior = 'smooth';\n            setTimeout(() => {\n                document.getElementsByTagName('html')[0].style.scrollBehavior = '';\n            }, 1000);\n        }\n    });\n});\n","/* \nimport '../scripts/utils/theme-functions.js';\nimport '../scripts/utils/css-helpers.js';\n*/\n\nwindow.theme = window.theme || {};\n\nimport '../scripts/components/';\nimport '../scripts/utils/helpers';\nconsole.log('main.bundle.js loaded');\n\n// Dispatch event when theme bundle is loaded\ndocument.dispatchEvent(new CustomEvent('theme:loaded'));\nwindow.theme.loaded = true;\n"],"names":["FavoriteHandler","storedFavorites","favorites","parsed","error","favoriteItem","favorite","el","favoriteHandler","FavoriteProducts","url","productHTML","res","arr","size","batchedArray","i","batchedFavorites","favoritesArray","productsHTML","AddFavorite","ReloadOnEvent","event","newContainer","html","fetchedShopifySection","fetchedSelf","sectionJSON","doc","path","element","selector","index","CurrencySelector","targetUrl","SectionTabNavigator","sectionId","activeTextClass","firstNavigator","evt","target","tabName","tabEl","show","targetRect","parentRect","blockEl","tabs","RadioBlob","afterCallstack","callback","truncateText","text","maxLength","ExpandText","maxChars","measureEl","parentWidth","sampleText","sampleEl","charsPerSample","sampleWidth","tempDiv","textContent","truncatePosition","truncatedText","VideoViewportManager","video","container","player","entries","entry","state","isIntersecting","playerData","type","playerState","paused","ResponsiveVideo","_a","source","media","viewportWidth","mobileSource","match","maxWidth","isActive","largeSource","minWidth","e","rect","activeSource","wasPlaying","icons$1","customLightbox","childSelector","galerySelector","mainClass","addListener","lightboxElements","createDataSourceItem","width","height","itemData","dataSource","pswpModule","PhotoSwipeLightbox","PhotoSwipe","lightbox","content","item","videoElement","videoSrc","createVideoElement","setupVideoEvents","initError","loaded","onLoaded","onError","setImageSources","img","setImageAttr","setImageSourceArray","imgElArray","initLazyImages","io","observer","imagesOnDOMLoad","imagesOnLoad","loadImagesOnDOMLoaded","loadImagesOnLoaded","imageElArray","execute","link"],"mappings":"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"}