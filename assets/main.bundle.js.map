{"version":3,"file":"main.bundle.js","sources":["../src/scripts/utils/utils.js","../src/scripts/utils/lazy-images.js","../src/entrypoints/theme.js"],"sourcesContent":["/**\n * Returns a function that as long as it continues to be invoked, won't be triggered.\n * @param {Function} fn - Callback function.\n * @param {number} [wait=300] - Delay (in milliseconds).\n * @returns {Function}\n */\nexport function debounce(fn, wait = 300) {\n    let t;\n    return (...args) => {\n        clearTimeout(t);\n        t = setTimeout(() => fn.apply(this, args), wait);\n    };\n}\n\n/**\n * Transforms a string from kebab-case to PascalCase.\n * @param {string} str - The input string in kebab-case.\n * @returns {string} - The transformed string in PascalCase.\n */\nexport function kebabToPascalCase(str) {\n    return str\n        .split('-') // Split the string by hyphens\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1)) // Capitalize the first letter of each word\n        .join(''); // Join the words back together\n}\n\n/**\n * Logs a message to the DOM by creating an <h4> element with the message,\n * appending it to the body, and removing it after a specified delay.\n *\n * @param {string} message - The message to display in the <h4> element.\n * @param {number} [delay=3000] - The delay in milliseconds before removing the <h4> element. Default is 3000ms.\n */\nexport function logDOM(message, delay = 8000) {\n    if (window.Shopify.theme.role != 'development') return;\n    const h4 = document.createElement('h4');\n    h4.textContent = message;\n    h4.style.color = 'red';\n\n    const logDomContainer = document.querySelector('[data-dom-log]') || document.body;\n\n    logDomContainer.prepend(h4);\n\n    setTimeout(() => {\n        logDomContainer.removeChild(h4);\n    }, delay);\n}\n\n/**\n * Waits for the animation to end on the specified element.\n *\n * @param {HTMLElement} element - The element to wait for the animation to end on.\n * @param {Function} [callback] - Optional callback function to execute when the animation ends.\n * @returns {Promise<void>} A promise that resolves when the animation ends.\n */\nexport async function afterAnimationEnd(element, callback) {\n    return new Promise((resolve) => {\n        function onEnd(event) {\n            if (event.target !== element) return;\n\n            element.removeEventListener('animationend', onEnd);\n            element.removeEventListener('transitionend', onEnd);\n\n            if (typeof callback === 'function') {\n                callback();\n            } else {\n                console.warn('callback was not valid function', callback);\n            }\n\n            resolve();\n        }\n\n        element?.addEventListener('animationend', onEnd);\n        element?.addEventListener('transitionend', onEnd);\n    });\n}\n\n/**\n * Executes the provided callback function after the current call stack has cleared.\n *\n * @param {Function} callback - The function to be executed after the call stack clears.\n */\nexport function afterCallstack(callback) {\n    setTimeout(() => {\n        requestAnimationFrame(callback);\n    }, 0);\n}\n\nexport function formatMoney(cents, format = window.themeVariables.moneyFormat) {\n    if (typeof cents == 'string') {\n        cents = cents.replace('.', '');\n    }\n    let value = '';\n    const placeholderRegex = /\\{\\{\\s*(\\w+)\\s*\\}\\}/;\n\n    function formatWithDelimiters(number, precision = 2, thousands = ',', decimal = '.') {\n        if (isNaN(number) || number == null) {\n            return 0;\n        }\n\n        number = (number / 100.0).toFixed(precision);\n\n        const parts = number.split('.'),\n            dollars = parts[0].replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, `$1${thousands}`),\n            cents = parts[1] ? decimal + parts[1] : '';\n\n        return dollars + cents;\n    }\n\n    switch (format.match(placeholderRegex)[1]) {\n        case 'amount':\n            value = formatWithDelimiters(cents, 2);\n            break;\n        case 'amount_no_decimals':\n            value = formatWithDelimiters(cents, 0);\n            break;\n        case 'amount_with_comma_separator':\n            value = formatWithDelimiters(cents, 2, '.', ',');\n            break;\n        case 'amount_no_decimals_with_comma_separator':\n            value = formatWithDelimiters(cents, 0, '.', ',');\n            break;\n    }\n\n    return format.replace(placeholderRegex, value);\n}\n","import { afterCallstack } from './utils.js';\n\n/**\n * Checks if a lazy load image has alternate <source> elements and copies the\n * 'data-src' and 'data-srcset' selectors to 'src' and 'srcset' accordingly.\n * @param {Element} img - Image element.\n */\nexport function setImageSources(img) {\n    const setImageAttr = (el) => {\n        if (el.dataset.src && !el.src) {\n            el.src = el.dataset.src;\n        }\n\n        if (el.dataset.srcset && !el.srcset) {\n            el.srcset = el.dataset.srcset;\n        }\n    };\n\n    if (img.parentNode.tagName === 'PICTURE') {\n        Array.from(img.parentNode.children).forEach((el) => {\n            setImageAttr(el);\n        });\n    } else {\n        setImageAttr(img);\n    }\n}\n\nfunction setImageSourceArray(imgElArray) {\n    return imgElArray.forEach((img) => setImageSources(img));\n}\n\n/**\n * Initialises lazy load images.\n */\nexport function initLazyImages() {\n    if ('loading' in HTMLImageElement.prototype === false && 'IntersectionObserver' in window) {\n        console.log('intersection observer');\n        const io = new IntersectionObserver(\n            (entries, observer) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        const img = entry.target;\n                        setImageSources(img);\n                        observer.unobserve(img);\n                    }\n                });\n            },\n            { rootMargin: '0px 0px 500px 0px' }\n        );\n\n        document.querySelectorAll('[loading=\"lazy\"]').forEach((img) => {\n            io.observe(img);\n        });\n    } else {\n        // If native lazy load supported or IntersectionObserver not supported (legacy browsers).\n        const imagesOnDOMLoad = [];\n        const imagesOnLoad = [];\n\n        document.querySelectorAll('[loading=\"lazy\"], [data-src]').forEach((img) => {\n            if (img.hasAttribute('data-load-dom')) {\n                imagesOnDOMLoad.push(img);\n            } else if (img.hasAttribute('data-load-load')) {\n                imagesOnLoad.push(img);\n            } else if (img.hasAttribute('data-load-manual')) {\n                return;\n            } else {\n                setImageSources(img);\n            }\n        });\n\n        loadImagesOnDOMLoaded(imagesOnDOMLoad);\n\n        loadImagesOnLoaded(imagesOnLoad);\n    }\n}\n\nfunction loadImagesOnDOMLoaded(imageElArray) {\n    console.debug('loadImagesOnDOMLoaded', imageElArray);\n    const execute = () => afterCallstack(() => setImageSourceArray(imageElArray));\n\n    if (document.readyState != 'loading') {\n        return execute();\n    }\n\n    document.addEventListener('DOMContentLoaded', execute);\n}\n\nfunction loadImagesOnLoaded(imageElArray) {\n    console.debug('loadImagesOnLoaded', imageElArray);\n    const execute = () => afterCallstack(() => setImageSourceArray(imageElArray));\n\n    if (document.readyState == 'complete') {\n        return execute();\n    }\n\n    window.addEventListener('load', execute);\n}\n\n//Loads all images manually (load,dom,manual, etc.)\nexport function loadManualImages(container = document) {\n    console.debug('loadManualImages', container);\n    const imageEls = container.querySelectorAll('[loading=\"lazy\"]');\n\n    setImageSourceArray(imageEls);\n}\n\nafterCallstack(initLazyImages);\ndocument.addEventListener('DOMContentLoaded', initLazyImages);\n","/* \nimport '../scripts/utils/theme-functions.js';\nimport '../scripts/utils/css-helpers.js';\n*/\n\nwindow.theme = {};\n\nimport '../scripts/components/';\nimport '../scripts/utils/lazy-images.js';\n\n// Dispatch event when theme bundle is loaded\ndocument.dispatchEvent(new CustomEvent('theme:loaded'));\n"],"names":["afterCallstack","callback","setImageSources","img","setImageAttr","el","setImageSourceArray","imgElArray","initLazyImages","io","entries","observer","entry","imagesOnDOMLoad","imagesOnLoad","loadImagesOnDOMLoaded","loadImagesOnLoaded","imageElArray","execute"],"mappings":"AAkFO,SAASA,EAAeC,EAAU,CACrC,WAAW,IAAM,CACb,sBAAsBA,CAAQ,CACjC,EAAE,CAAC,CACR,CC/EO,SAASC,EAAgBC,EAAK,CACjC,MAAMC,EAAgBC,GAAO,CACrBA,EAAG,QAAQ,KAAO,CAACA,EAAG,MACtBA,EAAG,IAAMA,EAAG,QAAQ,KAGpBA,EAAG,QAAQ,QAAU,CAACA,EAAG,SACzBA,EAAG,OAASA,EAAG,QAAQ,OAEnC,EAEQF,EAAI,WAAW,UAAY,UAC3B,MAAM,KAAKA,EAAI,WAAW,QAAQ,EAAE,QAASE,GAAO,CAChDD,EAAaC,CAAE,CAC3B,CAAS,EAEDD,EAAaD,CAAG,CAExB,CAEA,SAASG,EAAoBC,EAAY,CACrC,OAAOA,EAAW,QAASJ,GAAQD,EAAgBC,CAAG,CAAC,CAC3D,CAKO,SAASK,GAAiB,CAC7B,GAAI,cAAa,iBAAiB,YAAuB,yBAA0B,OAAQ,CACvF,QAAQ,IAAI,uBAAuB,EACnC,MAAMC,EAAK,IAAI,qBACX,CAACC,EAASC,IAAa,CACnBD,EAAQ,QAASE,GAAU,CACvB,GAAIA,EAAM,eAAgB,CACtB,MAAMT,EAAMS,EAAM,OAClBV,EAAgBC,CAAG,EACnBQ,EAAS,UAAUR,CAAG,CACzB,CACrB,CAAiB,CACJ,EACD,CAAE,WAAY,mBAAqB,CAC/C,EAEQ,SAAS,iBAAiB,kBAAkB,EAAE,QAASA,GAAQ,CAC3DM,EAAG,QAAQN,CAAG,CAC1B,CAAS,CACT,KAAW,CAEH,MAAMU,EAAkB,CAAA,EAClBC,EAAe,CAAA,EAErB,SAAS,iBAAiB,8BAA8B,EAAE,QAASX,GAAQ,CACvE,GAAIA,EAAI,aAAa,eAAe,EAChCU,EAAgB,KAAKV,CAAG,UACjBA,EAAI,aAAa,gBAAgB,EACxCW,EAAa,KAAKX,CAAG,MAClB,IAAIA,EAAI,aAAa,kBAAkB,EAC1C,OAEAD,EAAgBC,CAAG,EAEnC,CAAS,EAEDY,EAAsBF,CAAe,EAErCG,EAAmBF,CAAY,CAClC,CACL,CAEA,SAASC,EAAsBE,EAAc,CACzC,QAAQ,MAAM,wBAAyBA,CAAY,EACnD,MAAMC,EAAU,IAAMlB,EAAe,IAAMM,EAAoBW,CAAY,CAAC,EAE5E,GAAI,SAAS,YAAc,UACvB,OAAOC,EAAO,EAGlB,SAAS,iBAAiB,mBAAoBA,CAAO,CACzD,CAEA,SAASF,EAAmBC,EAAc,CACtC,QAAQ,MAAM,qBAAsBA,CAAY,EAChD,MAAMC,EAAU,IAAMlB,EAAe,IAAMM,EAAoBW,CAAY,CAAC,EAE5E,GAAI,SAAS,YAAc,WACvB,OAAOC,EAAO,EAGlB,OAAO,iBAAiB,OAAQA,CAAO,CAC3C,CAUAlB,EAAeQ,CAAc,EAC7B,SAAS,iBAAiB,mBAAoBA,CAAc,ECtG5D,OAAO,MAAQ,CAAA,EAMf,SAAS,cAAc,IAAI,YAAY,cAAc,CAAC"}